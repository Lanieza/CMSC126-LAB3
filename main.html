<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pathfinding Visualizer</title>
    <style>
      .grid {
        display: grid;
        grid-template-columns: repeat(10, 50px);
        gap: 2px;
        margin: 20px;
      }

      .cell {
        width: 50px;
        height: 50px;
        border: 1px solid #ccc;
        background: white;
        cursor: pointer;
      }

      .start {
        background-color: green;
      }
      .end {
        background-color: red;
      }
      .wall {
        background-color: black;
      }
      .visited {
        background-color: lightblue;
      }
      .path {
        background-color: yellow;
      }

      .controls {
        margin: 20px;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <button onclick="startPathfinding()">Find Path</button>
      <button onclick="clearGrid()">Clear Grid</button>
    </div>
    <div id="grid" class="grid"></div>

    <script>
      class Node {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.isWall = false;
          this.distance = Infinity;
          this.isVisited = false;
          this.previousNode = null;
        }
      }

      class Grid {
        constructor(size) {
          this.size = size;
          this.nodes = [];
          this.startNode = null;
          this.endNode = null;
          this.initializeGrid();
        }

        initializeGrid() {
          const gridContainer = document.getElementById("grid");
          gridContainer.innerHTML = "";

          for (let i = 0; i < this.size; i++) {
            this.nodes[i] = [];
            for (let j = 0; j < this.size; j++) {
              const node = new Node(i, j);
              this.nodes[i][j] = node;

              const cell = document.createElement("div");
              cell.className = "cell";
              cell.dataset.x = i;
              cell.dataset.y = j;

              cell.addEventListener("click", () =>
                this.handleCellClick(node, cell)
              );
              gridContainer.appendChild(cell);
            }
          }
        }

        handleCellClick(node, cell) {
          if (!this.startNode) {
            this.startNode = node;
            cell.classList.add("start");
          } else if (!this.endNode) {
            this.endNode = node;
            cell.classList.add("end");
          } else {
            node.isWall = !node.isWall;
            cell.classList.toggle("wall");
          }
        }

        getNeighbors(node) {
          const neighbors = [];
          const directions = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];

          for (const [dx, dy] of directions) {
            const x = node.x + dx;
            const y = node.y + dy;
            if (x >= 0 && x < this.size && y >= 0 && y < this.size) {
              neighbors.push(this.nodes[x][y]);
            }
          }
          return neighbors;
        }
      }

      class Pathfinder {
        constructor(grid) {
          this.grid = grid;
          this.unvisitedNodes = [];
        }

        async dijkstra() {
          this.grid.startNode.distance = 0;
          this.unvisitedNodes = [this.grid.startNode];

          while (this.unvisitedNodes.length > 0) {
            this.unvisitedNodes.sort((a, b) => a.distance - b.distance);
            const currentNode = this.unvisitedNodes.shift();

            if (currentNode === this.grid.endNode) break;
            if (currentNode.isVisited) continue;

            currentNode.isVisited = true;
            this.updateCell(currentNode, "visited");

            await new Promise((resolve) => setTimeout(resolve, 50));

            const neighbors = this.grid.getNeighbors(currentNode);
            for (const neighbor of neighbors) {
              if (neighbor.isWall || neighbor.isVisited) continue;

              const newDistance = currentNode.distance + 1;
              if (newDistance < neighbor.distance) {
                neighbor.distance = newDistance;
                neighbor.previousNode = currentNode;
                this.unvisitedNodes.push(neighbor);
              }
            }
          }

          if (this.grid.endNode.previousNode) {
            await this.showPath();
          }
        }

        async showPath() {
          let currentNode = this.grid.endNode;
          while (currentNode !== this.grid.startNode) {
            this.updateCell(currentNode, "path");
            currentNode = currentNode.previousNode;
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
        }

        updateCell(node, className) {
          const cell = document.querySelector(
            `[data-x="${node.x}"][data-y="${node.y}"]`
          );
          cell.classList.add(className);
        }
      }

      const grid = new Grid(10);

      function startPathfinding() {
        const pathfinder = new Pathfinder(grid);
        pathfinder.dijkstra();
      }

      function clearGrid() {
        grid.startNode = null;
        grid.endNode = null;
        grid.initializeGrid();
      }
    </script>
  </body>
</html>
